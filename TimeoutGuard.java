package com.myapp.service.aop;import org.slf4j.Logger;import org.slf4j.LoggerFactory;/** * The Timer class allows a graceful exit when an application is stalled due to * a networking timeout. Once the timer is set, it must be cleared via the * reset() method, or the timeout() method is called. * <p> * The timeout length is customizable, by changing the 'timeoutTreshold' property, or * through the constructor. The length represents the length of the timer in * milliseconds. *  * @author David Reilly * Modified by @author npeeters */public class TimeoutGuard extends Thread {	final static Logger logger = LoggerFactory.getLogger(TimeoutGuard.class);			/** Rate at which timer is checked */	protected int checkInterval = 1000; // check ever 1s	/** Length of timeout */	private int timeoutTreshold;	/** Time elapsed */	private int timeElapsed;	/** Some context info, useful for debugging */	private String contextInfo;	 	/**	 * Creates a timer of a specified length	 * 	 * @param length Length of time before timeout occurs	 */	public TimeoutGuard(int length) {		// Assign to member variable		timeoutTreshold = length;		// Set time elapsed		timeElapsed = 0;	}	/**	 * Creates a timer of a specified length	 * 	 * @param length Length of time before timeout occurs	 */	public TimeoutGuard(int length, String contextInfo) {		// Assign to member variable		timeoutTreshold = length;		// Set time elapsed		timeElapsed = 0;		this.contextInfo = contextInfo;	}		/** Resets the timer back to zero */	public synchronized void reset() {		logger.info("OK, nothing went wrong, resetting the timeout **************");		timeElapsed = 0;	}	/** Performs timer specific code */	public void run() {		int step = 0;		// Keep looping		for (;;) {			// Put the timer to sleep			try {				logger.info("Checking health. Step {}",++step);				Thread.sleep(checkInterval);			} catch (InterruptedException ioe) {				continue;			}			// Use 'synchronized' to prevent conflicts			synchronized (this) {				// Increment time remaining				timeElapsed += checkInterval;				// Check to see if the time has been exceeded				if (timeElapsed > timeoutTreshold) {					// Trigger a timeout					logger.warn("Going to generate a timeout **************");					timeout();				}			}		}	}	// Override this to provide custom functionality	public void timeout() {		logger.warn("Timeout occurred for {}! Configured maximum value was {}", this.contextInfo, this.timeoutTreshold);		throw new RuntimeException("Timeout occurred! Configured maximum value was: " +this.timeoutTreshold);	}}